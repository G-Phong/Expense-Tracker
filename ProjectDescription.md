# Project: Expense Tracker

Idea contributed by Gia-Phong Tran <giaphong.tran@tum.de> and Peter Riske <peter.riske@tum.de>.

## Motivation

The goal of this project is to build a tool which helps people to have an overview over their group expenses. This tool is supposed to track common expenses (spent in a group or as a single individual) and to create an overview over the cash flows, e.g. of a group vacation. The Expense Tracker makes it easy to split bills with friends and family - everybody can see who they owe. Whether you are sharing a beach vacation, splitting rent with roommates or paying someone back for dinner, it makes life just easier!

The Expense Tracker is able to share group expenses in an efficient way, i.e. to reduce the number of necessary transactions. Users of this tool will be able to view the status of their own account and the balance of their groups.

## Sprint 1 (basics)

In the first sprint the main functionality is implemented: the user shall be created, i.e. the user name is determined and a user account is created. Then, the user can create a group and add expenses. Adding expenses will change the balance of the group. You do not need to use classes, you can write plain functions and variables. The user interface for the Expense Tracker tool can be command line based, for example.

### Sprint 1: Definition of "done"

The version will be considered as "complete" if the:

- User can create a user account, containing the name of the user and its personal money account.
- User can create a group. The group has a group name and the number of members should not be fixed.
- User can add expenses to its group(s)
- User balance can be displayed (e.g. printed in terminal). The user should see if they owe money or if they get money.

Optional:

- An expense can be edited subsequently, i.e. after it was made.
- User can leave its group(s).

## Sprint 2 (OOP)

The goal of the second sprint is to use object-oriented principles: there will be classes for users and groups. Multiple users can be created and they can join different groups. A user can make expenses for an arbitrary number of persons - themselves included.

**Example of transaction:**
```
Alice, Bob and Mallory are members of the group "Friends".

User "Alice" pays cinema tickets for "Bob" and "Mallory" worth 15€ each.
```

**Group balance after Alice transaction:**
```
Friends.Alice.Account = + 30€

Friends.Bob.Account = - 15€

Friends.Mallory.Account = - 15€
```

Of course, the settlement of accounts within a group should be displayed. The question "Who owes what to whom?" should be clearly answered.

**The output format should be somewhat similar to:**
  
```
1) Bob owes Alice 15€

2) Mallory owes Alice 15€

3) Alice receives 30€ from Bob and Mallory.
```
Note that the number of paybacks should be as small as possible, so users don't have to make hundreds of transactions!

### Sprint 2: Definition of "done"

The version will be considered as "complete" if the

- Multiple users and groups can be created. Every user can join every group.
- Group members can be displayed.
- Focus on: Expense Tracker is able to show an overview of who clears which debt in a structured way (see above).

Optional:

- Debts that exist across groups between two or more users are to be combined (cross-group dependencies).
- Users can split expenses inequally, e.g. "Bob" only pays back 10€ and "Mallory" pays back 20€ to "Alice".
- Built-in payback function: whenever a user pays back their debts, the group balance will be updated. A group balance is settled if there are no more unsettled debts and every individual account balance within the group is 0.

## Sprint 3 (performance and/or STL)

In the final sprint, the code performance will be evaluated and improved. Finding potential bottlenecks and investigating optimization options for the code, including loop transformations, Standard Template Library (STL) containers, vectorization options and complexity analysis to find potential improvements will be part of this sprint.

To compare code performance, a second modification of the program should be implemented. Refactoring functions, restructuring the source code, using different data structures and varying the algorithms of the program could be considered. In the end both versions of the Expense Tracker program should be compared while the focus should be on performance. Whether the efficiency improved or not should be evaluated.

### Sprint 3: Definition of "done"

- A modification of the code is implemented, which has the same functionality but a different code structure (as stated above).
- Create autogenerated file to simulate performance with higher computational effort
- Challenge your code by simulating a large number of users and groups. You could use an auto-generated file to import all the users and groups (e.g. CSV file).
- Compare the original version and the modification. Check if the efficiency is improved or not. In order to compare the performances, both codes should be profiled. The modification contains at least one different optimization technique you applied, with the observable performance effects. Using STL containers could be a first step.
- Code Profiling: Use a C++ profiler (e.g. GNU gprof or Valgrind) to profile the code. Profiling allows to learn where the program spent its time and which functions called which other functions while it was executing. This information can show which pieces of the program are slower than expected and might be candidates for rewriting.
- A file <kbd>performance.md</kbd> presents the observations from the performance analysis

Optional:

- If transactions are stored to a file, then also think about optimizing the file processing to improve efficiency. Notice: Optimization of I/O file processing or parallelization is not part of the Advanced Programming course. Try to do some online research instead.
